 // bison syntax to indicate the beginning of a C/C++ code section*/
%{
  

extern int yylex();  // prototype of function generated by flex
extern int yyerror(const char *); // used to print errors
extern int line_count;            // current line in the input; from record.l

#include "error.h"      // class for printing errors (used by gpl)
#include "parser.h"
#include <iostream>
#include <string>

#define PI 3.14159265
using namespace std;

template<typename BINOP, Operator_type NM>
Expression* Bin_op_check(Expression* one, Expression* three, unsigned int valid_types)
{ 
        unsigned int lh_valid=one->type() & valid_types;
        unsigned int rh_valid=three->type() & valid_types;
        if(!lh_valid){ Error::error(Error::INVALID_LEFT_OPERAND_TYPE,operator_to_string(NM)); }
        if(!rh_valid){ Error::error(Error::INVALID_RIGHT_OPERAND_TYPE,operator_to_string(NM)); }
        
        if(lh_valid && rh_valid){ return new BINOP(one, three); }
        else { 
          delete one;
          delete three;
          return new Integer_constant(0); }
}



template<typename UNOP, Operator_type NM>
Expression* Un_op_chack(Expression* three, unsigned int valid_types){
        unsigned int value_valid = three->type() & valid_types;
        if(!value_valid) {Error::error(Error::INVALID_RIGHT_OPERAND_TYPE,operator_to_string(NM));}
        if(value_valid){  return new UNOP(three);}
        else {
           delete three;
           return new Integer_constant(0); }

}
// bison syntax to indicate the end of a C/C++ code section
%} 


// turn on verbose (longer) error messages
%define parse.error verbose

%union {
 Window::Keystroke  union_key;
 int            union_int;
 std::string*   union_string;  // MUST be a pointer to a string
 double         union_double;
 Gpl_type       union_gpl_type;
 Expression*    union_expression_ptr; 
 Variable*      union_variable_ptr;
 Parameter*	union_parameter_ptr;
 Statement*	union_statement_ptr;
};

 /* tokens declared here---------------*/
 /* updated January 2019 
  * Copy the following token declarations into your .y file. */

 /* Tokens with angle braces < > after %token require a type. 
  * This is the type of the variable the scanner (flex) puts into the union.
  * Fill in the < > with the appropriate union variable
  *     for example
  *     %token <union_int> T_INT_CONSTANT       "int constant" 
  */

%token T_INT                 "int"
%token T_DOUBLE              "double"
%token T_STRING              "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"

%token <union_int> T_FORWARD         "forward"  /* value is line number */
%token T_INITIALIZATION      "initialization"
%token T_TERMINATION         "termination"
%token T_ON                  "on"
%token T_ANIMATION           "animation"
%token T_IF                  "if"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_int> T_EXIT            "exit"  /* value is line number */
%token <union_int> T_PRINT           "print"  /* value is line number */
%token T_TRUE                "true"
%token T_FALSE               "false"

%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"

%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."

%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"

%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_ABS                 "abs"
%token T_FLOOR               "floor"
%token T_RANDOM              "random"

%token T_TOUCHES             "touches"
%token T_NEAR                "near"

%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_MOD                 "%"

%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="
%token T_NOT                 "!"
%token T_AND                 "&&"
%token T_OR                  "||"

%token <union_int> T_INT_CONSTANT    "int constant"
%token <union_double> T_DOUBLE_CONSTANT "double constant"
%token <union_string> T_STRING_CONSTANT "string constant"
%token <union_string> T_ID            	 "identifier"

 /* special token that does not match any production */
 /* used for characters that are not part of the language */
%token T_ERROR               "error"

%left T_OR
%left T_AND
%left T_EQUAL T_NOT_EQUAL
%left T_LESS T_LESS_EQUAL T_GREATER T_GREATER_EQUAL
%left T_PLUS T_MINUS
%left T_MULTIPLY T_DIVIDE T_MOD
%nonassoc T_NOT UNARY_OPS
%nonassoc IF_NO_ELSE
%nonassoc T_ELSE
%left T_TOUCHES T_NEAR
%type <union_string> animation_declaration

%type <union_statement_ptr> for_statement
%type <union_statement_ptr> statement_or_block_of_statements
%type <union_statement_ptr> if_statement

%type <union_statement_ptr> exit_statement
%type <union_statement_ptr> assign_statement_or_empty
%type <union_statement_ptr> assign_statement
%type <union_key> keystroke
%type <union_statement_ptr> statement_block
%type <union_statement_ptr> statement_list
%type <union_statement_ptr> statement
%type <union_statement_ptr> print_statement
%type <union_gpl_type> object_type
%type <union_gpl_type> animation_parameter
%type <union_gpl_type> simple_type
%type <union_expression_ptr> primary_expression
%type <union_expression_ptr> expression
%type <union_expression_ptr> optional_initializer
%type <union_variable_ptr> variable
%type <union_parameter_ptr> parameter
%type <union_parameter_ptr> parameter_list
%type <union_parameter_ptr> parameter_list_or_empty
%%
// updated January 2019

 /*change above?---------------------------------------------------------------------*/
program:
    declaration_list block_list{
     std::set<std::string> undefined;
      std::set<std::string> used_undefined;
      Table_handler& th = Table_handler::instance();
     //get the difference of sets that are used by game objects but never defined 
     std::set_difference(Animation_code::used_blocklist.begin(), Animation_code::used_blocklist.end(), Animation_code::defined_blocklist.begin(), Animation_code::defined_blocklist.end(), std::inserter(used_undefined, used_undefined.end()));

     for(auto i = used_undefined.begin(); i != used_undefined.end(); ++i){
       Error::error(Error::NO_BODY_PROVIDED_FOR_FORWARD, *i);
     }     


     //get the difference of the sets that were declared but undefined and sets that were defined
     std::set_difference(Animation_code::declared_blocklist.begin(), Animation_code::declared_blocklist.end(), Animation_code::defined_blocklist.begin(), Animation_code::defined_blocklist.end(), std::inserter(undefined, undefined.end()));
     for(auto it = undefined.begin(); it!=undefined.end(); ++it){
       th.erase(*it);
     }
    }
    ;

 /*---------------------------------------------------------------------*/
declaration_list:
    declaration_list declaration
    | empty
    ;

 /*---------------------------------------------------------------------*/
declaration:
    variable_declaration T_SEMIC
    | object_declaration T_SEMIC
    | forward_declaration T_SEMIC
    ;

 /*---------------------------th handler lookup broken------------------------------------------*/
variable_declaration:
    simple_type  T_ID  optional_initializer
   {
      Table_handler& th = Table_handler::instance();
      if(th.defined_in_current_scope(*$2) == true){
         Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
      
      }
      else{
         try{
            if($1 == INT){
               int vall=0;
               if($3!=nullptr) vall=$3->evaluate()->as_int();
               th.insert(std::make_shared<Symbol>(*$2, new int(vall)));
            }
            if($1 == DOUBLE){
               
               double vall = 0.0;
               if($3!=nullptr){vall=$3->evaluate()->as_double();}
               
               th.insert(std::make_shared<Symbol>(*$2, new double(vall)));
            }
            if($1 == STRING){
                std::string vall = "";
                if($3!=nullptr){
                   vall=$3->evaluate()->as_string();
                  
                }
               
               th.insert(std::make_shared<Symbol>(*$2, new string(vall)));
	     
            }
         }   
         catch(Gpl_type unexpected_type){
            Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, gpl_type_to_string(unexpected_type), *$2, gpl_type_to_string($1));
            
            switch($1){
               case INT:
                  th.insert(std::make_shared<Symbol>(*$2, new int(0)));
               break;
               case DOUBLE:
                  th.insert(std::make_shared<Symbol>(*$2, new double(0.0)));
               break;
	       case STRING:
                  th.insert(std::make_shared<Symbol>(*$2, new string("")));
               break;
	      default:
		  std::cerr <<"bug at variable declration production error switch statement\n";
                  assert(false);
		  
            }
         }
      }
      delete $2;
      delete $3;
   }
    | simple_type  T_ID T_LBRACKET expression T_RBRACKET
      {

         Table_handler& th = Table_handler::instance();
         if(th.defined_in_current_scope(*$2) == true){
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2); 
         }
        
         else if($4->type() != INT){
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, gpl_type_to_string($4->type()), *$2);
         }
          else if($4->evaluate()->as_int() <= 0 ){
            Error::error(Error::INVALID_ARRAY_SIZE, *$2, std::to_string($4->evaluate()->as_int()));
         }
         else{
            const int x = $4->evaluate()->as_int();
             if($1 == INT){
               
               auto p = new int[x];
               
               
               for(int i=0; i < x; ++i){
                  p[i] = 0;
               }
               th.insert(std::make_shared<Symbol>(*$2, p, x));
            }
            else if($1 == DOUBLE){
               auto p = new double[x];
               for(int i=0; i < x; ++i){
                  p[i] = 0.0;
               }
               th.insert(std::make_shared<Symbol>(*$2, p, x));
            }
            else if($1 == STRING){
               auto p = new string[x];
               for(int i=0; i < x; ++i){
                  p[i] = "";
               }
               th.insert(std::make_shared<Symbol>(*$2, p, x));
            }
         }
         delete $2;
      }
    ;

 /*---------------------------------------------------------------------*/
simple_type:
    T_INT {$$=INT;}
    | T_DOUBLE {$$=DOUBLE;}
    | T_STRING {$$=STRING;}
    ;

 /*---------------------------------------------------------------------*/
optional_initializer:
    T_ASSIGN expression {$$=$2;} 
    | empty {$$=nullptr;}
    ;

 /*---------------------------------------------------------------------*/
object_declaration:
    object_type T_ID parameter_list_or_empty{
      
      Table_handler& th=Table_handler::instance();
      if(th.defined_in_current_scope(*$2) == true){
         Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);

      }
      
      else{
      Game_object* gop;
      
      switch($1) {
        case RECTANGLE:{
          Rectangle* ptr=new Rectangle;
          gop=ptr;
          th.insert(std::make_shared<Symbol>(*$2, ptr));
             
          if($3 == nullptr) break;
          else{
            Parameter* para = $3;
            while(para != nullptr){
              Gpl_type type = para->expression->type();
	      try{
                if(gop->attribute_type(para->name)==INT){
                  gop->write_attribute(para->name, para->expression->evaluate()->as_int());
                }
                if(gop->attribute_type(para->name)==STRING){
                  gop->write_attribute(para->name, para->expression->evaluate()->as_string());
                }
                if(gop->attribute_type(para->name)==DOUBLE){
                  
                  gop->write_attribute(para->name, para->expression->evaluate()->as_double());
                }
                 if(gop->attribute_type(para->name)==ANIMATION_BLOCK){
                  const Animation_code* anim_block = para->expression->evaluate()->as_animation_block();
                  gop->write_attribute(para->name, anim_block);
                  Animation_code::used_blocklist.insert(anim_block->get_block_name()); 
              }
              }catch(Gpl_type unexpected_type){ Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, para->name); }
               catch(const out_of_range& nm){ Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), para->name);}
               
               catch(...){std::cerr << "more errors in object declaration"; break;}

              para = para->next;
            }
          break;
          }


       }//rectangle
      case CIRCLE:{
        Circle* ptr=new Circle;
        gop=ptr;
        th.insert(std::make_shared<Symbol>(*$2,ptr));
        if($3 == nullptr) break;
        else{
          Parameter* para = $3;
         Gpl_type type = para->expression->type();
          while(para != nullptr){
            
	    try{
              if(gop->attribute_type(para->name)==INT){
                gop->write_attribute(para->name, para->expression->evaluate()->as_int());
              }
              if(gop->attribute_type(para->name)==STRING){
                gop->write_attribute(para->name, para->expression->evaluate()->as_string());
              }
              if(gop->attribute_type(para->name)==DOUBLE){
                gop->write_attribute(para->name, para->expression->evaluate()->as_double());
              }
                if(gop->attribute_type(para->name)==ANIMATION_BLOCK){
                  const Animation_code* anim_block = para->expression->evaluate()->as_animation_block();
                  gop->write_attribute(para->name, anim_block);
                  Animation_code::used_blocklist.insert(anim_block->get_block_name()); 
              }
            } catch(Gpl_type unexpected_type){ Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, para->name); }
           catch(const out_of_range& nm){ Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), para->name);}
               
           catch(...){std::cerr << "more errors in object declaration"; break;}

            para = para->next;
          }
        }
         break;
      }
      case TEXTBOX:{
          Textbox* ptr=new Textbox;
          gop=ptr; 
          th.insert(std::make_shared<Symbol>(*$2, ptr));
        if($3==nullptr) break;
        else{
          Parameter* para = $3;
          Gpl_type type = para->expression->type();
          while(para != nullptr){
	    try{
              if(gop->attribute_type(para->name)==INT){
                gop->write_attribute(para->name, para->expression->evaluate()->as_int());
              }
              if(gop->attribute_type(para->name)==STRING){
                gop->write_attribute(para->name, para->expression->evaluate()->as_string());
              }
              if(gop->attribute_type(para->name)==DOUBLE){
                gop->write_attribute(para->name, para->expression->evaluate()->as_double());
              }
                 if(gop->attribute_type(para->name)==ANIMATION_BLOCK){
                  const Animation_code* anim_block = para->expression->evaluate()->as_animation_block();
                  gop->write_attribute(para->name, anim_block);
                  Animation_code::used_blocklist.insert(anim_block->get_block_name()); 
              }
            }catch(Gpl_type unexpected_type){ Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, para->name);}
             catch(const out_of_range& nm){ Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), para->name); }
               
             catch(...){std::cerr << "more errors in object declaration"; break;}

            para = para->next;

          }
        }
        break;
      }
      case TRIANGLE:{
        Triangle* ptr=new Triangle;
        gop=ptr; 
        th.insert(std::make_shared<Symbol>(*$2, ptr));
        if($3==nullptr) break;
        else{
          Parameter* para = $3;
          Gpl_type type = para->expression->type();
          while(para != nullptr){
	    try{
              if(gop->attribute_type(para->name)==INT){
                gop->write_attribute(para->name, para->expression->evaluate()->as_int());
              }
              if(gop->attribute_type(para->name)==STRING){
                gop->write_attribute(para->name, para->expression->evaluate()->as_string());
              }
              if(gop->attribute_type(para->name)==DOUBLE){
                gop->write_attribute(para->name, para->expression->evaluate()->as_double());
              } 
              if(gop->attribute_type(para->name)==ANIMATION_BLOCK){
                const Animation_code* anim_block = para->expression->evaluate()->as_animation_block();
                gop->write_attribute(para->name, anim_block);
                Animation_code::used_blocklist.insert(anim_block->get_block_name()); 
              }
            }catch(Gpl_type unexpected_type){ Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, para->name); }
             catch(const out_of_range& nm){ Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), para->name);}
               
             catch(...){std::cerr << "more errors in object declaration"; break;}

            para = para->next;

          }
        }
	break;
      }
       case PIXMAP:{
         Pixmap* ptr=new Pixmap;
         gop=ptr; 
         th.insert(std::make_shared<Symbol>(*$2, ptr));
        if($3==nullptr) break;
         else{
           Parameter* para = $3;
           Gpl_type type = para->expression->type();
            while(para != nullptr){
	      try{
                if(gop->attribute_type(para->name)==INT){
                  gop->write_attribute(para->name, para->expression->evaluate()->as_int());
              }
                if(gop->attribute_type(para->name)==STRING){
                  gop->write_attribute(para->name, para->expression->evaluate()->as_string());
              }
                if(gop->attribute_type(para->name)==DOUBLE){
                  gop->write_attribute(para->name, para->expression->evaluate()->as_double());
              } 
                if(gop->attribute_type(para->name)==ANIMATION_BLOCK){
                  const Animation_code* anim_block = para->expression->evaluate()->as_animation_block();
                  gop->write_attribute(para->name, anim_block);
                  Animation_code::used_blocklist.insert(anim_block->get_block_name()); 
              }
            }catch(Gpl_type unexpected_type){ Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, para->name);}
             catch(const out_of_range& nm){ Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), para->name);}
               
             catch(...){std::cerr << "more errors in object declaration"; break;}

            para = para->next;

          }
        }
	break;
       }
       
       default:{
         std::cerr << "you suck at programming dude gpl.y object declaration production\n";
         break;	
       }
    }
    }
    
    }
    | object_type T_ID T_LBRACKET expression T_RBRACKET
 {
	 
         
         Table_handler& th = Table_handler::instance();
         Gpl_type t = $1;
         if(th.defined_in_current_scope(*$2) == true){
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
         }

         else if($4->type() != INT){
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, gpl_type_to_string($4->type()), *$2);
            const int x = 1;
             if($1 == CIRCLE){

               Circle* circArr = new Circle[1];   
               th.insert(std::make_shared<Symbol>(*$2, circArr, 1));
            }
            else if($1 == RECTANGLE){
               Rectangle* rectArr = new Rectangle[1];
               th.insert(std::make_shared<Symbol>(*$2, rectArr, 1));
            }
            else if($1 == TEXTBOX){
               Textbox* textArr = new Textbox[x];
               
               th.insert(std::make_shared<Symbol>(*$2, textArr, x));
            }
            else if($1 == TRIANGLE){
               Triangle* triArr = new Triangle[x];
              
               th.insert(std::make_shared<Symbol>(*$2, triArr, x));
            }
            else if($1 == PIXMAP){
               Pixmap* pixArr = new Pixmap[x];
               
               th.insert(std::make_shared<Symbol>(*$2, pixArr, x));
            }
         }
          else if($4->evaluate()->as_int() <= 0 ){
            Error::error(Error::INVALID_ARRAY_SIZE, *$2, std::to_string($4->evaluate()->as_int()));
            const int x =1;
            if($1 == CIRCLE){
               Circle* circArr = new Circle[x];
               th.insert(std::make_shared<Symbol>(*$2, circArr, x));
            }
            else if($1 == RECTANGLE){
               Rectangle* rectArr = new Rectangle[x];
               th.insert(std::make_shared<Symbol>(*$2, rectArr, x));
            }
            else if($1 == TEXTBOX){
               Textbox* textArr = new Textbox[x];
               
               th.insert(std::make_shared<Symbol>(*$2, textArr, x));
            }
            else if($1 == TRIANGLE){
               Triangle* triArr = new Triangle[x];
              
               th.insert(std::make_shared<Symbol>(*$2, triArr, x));
            }
            else if($1 == PIXMAP){
               Pixmap* pixArr = new Pixmap[x];
               
               th.insert(std::make_shared<Symbol>(*$2, pixArr, x));
            }
         }
         else{
            const int x = $4->evaluate()->as_int();
             if($1 == CIRCLE){

               Circle* circArr = new Circle[x];
         

               
               th.insert(std::make_shared<Symbol>(*$2, circArr, x));
            }
            else if($1 == RECTANGLE){
               Rectangle* rectArr = new Rectangle[x];
               th.insert(std::make_shared<Symbol>(*$2, rectArr, x));
            }
            else if($1 == TEXTBOX){
               Textbox* textArr = new Textbox[x];
               
               th.insert(std::make_shared<Symbol>(*$2, textArr, x));
            }
            else if($1 == TRIANGLE){
               Triangle* triArr = new Triangle[x];
              
               th.insert(std::make_shared<Symbol>(*$2, triArr, x));
            }
            else if($1 == PIXMAP){
               Pixmap* pixArr = new Pixmap[x];
               
               th.insert(std::make_shared<Symbol>(*$2, pixArr, x));
            }
         }
         delete $2;
      }

    ;

 /*---------------------------------------------------------------------*/
object_type:
    T_TRIANGLE {$$ = TRIANGLE;}
    | T_PIXMAP {$$ = PIXMAP;}
    | T_CIRCLE {$$ = CIRCLE;}
    | T_RECTANGLE {    $$ = RECTANGLE;}
    | T_TEXTBOX {$$ = TEXTBOX;}
    ;

 /*---------------------------------------------------------------------*/
parameter_list_or_empty :
    T_LPAREN parameter_list T_RPAREN{$$ = $2;}
    | T_LPAREN empty T_RPAREN{$$=nullptr;}
    | empty{$$=nullptr;}
    ;

 /*---------------------------------------------------------------------*/
parameter_list :
    parameter_list T_COMMA parameter{
      Parameter* last=$1;
      while(last->next!=nullptr) last=last->next;
      last->next=$3;
      $$=$1;
    }
    | parameter{$$ = $1;}
    ;

 /*---------------------------------------------------------------------*/
parameter:
    T_ID T_ASSIGN expression{//need to do error checking for this 
      $$=new Parameter{$3, *$1, nullptr};
      delete $1;
    }
    ;

 /*---------------------------------------------------------------------*/
block_list:
    block_list block
    | empty
    ;

 /*---------------------------------------------------------------------*/
block:
    initialization_block
    | termination_block
    | animation_block
    | on_block
    ;

 /*---------------------------------------------------------------------*/
initialization_block:
    T_INITIALIZATION statement_block{
       Event_manager& eh = Event_manager::instance();
      eh.add_handler(Window::INITIALIZE, $2);

    }
    ;

 /*---------------------------------------------------------------------*/
termination_block:
    T_TERMINATION statement_block{
       Event_manager& eh = Event_manager::instance();
      eh.add_handler(Window::TERMINATE, $2);

    }
    ;

 /*---------------------------------------------------------------------*/
forward_declaration:
    T_FORWARD T_ANIMATION T_ID T_LPAREN animation_parameter T_RPAREN{
      Table_handler& th = Table_handler::instance();
      if(th.defined_in_current_scope(*$3) == true){
        Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$3);
      }
      Animation_code* a_code = new Animation_code(*$3, $5);
      th.insert(std::make_shared<Symbol>(*$3, a_code));
      a_code->declared_blocklist.insert(*$3);
      
    }
    ;

 /*---------------------------------------------------------------------*/
animation_parameter:
    object_type T_ID{$$ = $1;}
    | object_type{$$ = $1;}
    ;

 /*---------------------------------------------------------------------*/
animation_block:
    animation_declaration statement_block{
        Table_handler& th = Table_handler::instance();
        
        // Pop the symbol table off the stack
        th.pop_table();

        // If block's name isn't nullptr
        if($1 != nullptr)
        {
            // Retrieve symbol & set it's statement pointer
            auto sym = th.lookup(*$1);
            sym->as_lvalue()->mutate($2); // GIVING AN ERROR IN
            Animation_code::defined_blocklist.insert(*$1);

       }
    }
    ;

 /*---------------------------------------------------------------------*/
animation_declaration:
    T_ANIMATION T_ID T_LPAREN object_type T_ID T_RPAREN{
      $$ = nullptr;
      Table_handler& th = Table_handler::instance();
      std::shared_ptr<Symbol> sym = th.lookup(*$2);
      if(sym == nullptr){//had no forward decleration
        th.insert(std::make_shared<Symbol>(*$2,new Animation_code(*$2, $4 ))); 
      }
      sym = th.lookup(*$2);
     if(sym->get_type() == ANIMATION_CODE)
      {
        std::shared_ptr<const Constant> anim_const{sym->as_constant()};
        Gpl_type the_parameter_type=anim_const->as_animation_block()->get_parameter_type();
       
      //  Gpl_type the_parameter_type = sym->as_constant()->as_animation_block()->get_parameter_type();
        
        if($4 == the_parameter_type){ //forward declaration and definition match
          sym->as_lvalue()->mutate(*$5);
          $$ = $2;
        }
        else{
          Error::error(Error::ANIMATION_PARAM_DOES_NOT_MATCH_FORWARD, gpl_type_to_string($4), gpl_type_to_string(the_parameter_type));
        }
     
      }
      else{//symbol isn't an animation block
        Error::error(Error::REDECLARATION_OF_SYMBOL_AS_ANIMATION_BLOCK, *$2);
      }
      th.push_table();
      Game_object* gop;
        switch($4)
        {
            case CIRCLE:
            {
                Circle* ptr = new Circle;
                gop = ptr;
                th.insert(make_shared<Symbol>(*$5, ptr));
                break;
            }
            case RECTANGLE:
            {
              Rectangle* ptr = new Rectangle;
                gop = ptr;
                th.insert(make_shared<Symbol>(*$5, ptr));
                break;
 
            } 
            case PIXMAP:
            {
                Pixmap* ptr = new Pixmap;
                gop = ptr;
                th.insert(make_shared<Symbol>(*$5, ptr));
                break;
 
            }   
            case TRIANGLE:
            {
                Triangle* ptr = new Triangle;
                gop = ptr;
                th.insert(make_shared<Symbol>(*$5, ptr));
                break;
 
            }
            case TEXTBOX:
            {
                Textbox* ptr = new Textbox;
                gop = ptr;
                th.insert(make_shared<Symbol>(*$5, ptr));
                break;
 
            }
        }
    }
    ;

 /*---------------------------------------------------------------------*/
on_block:
    T_ON keystroke statement_block{
      Event_manager& eh = Event_manager::instance();
      eh.add_handler($2, $3);
    }
    ;

 /*---------------------------------------------------------------------*/
keystroke:
    T_SPACE {$$=Window::SPACE;
}
    | T_UPARROW {$$=Window::UPARROW;
}
    | T_DOWNARROW {$$=Window::DOWNARROW;
}
    | T_LEFTARROW {$$=Window::LEFTARROW;
}
    | T_RIGHTARROW {$$=Window::RIGHTARROW;
}
    | T_LEFTMOUSE_DOWN {$$=Window::LEFTMOUSE_DOWN;
}
    | T_MIDDLEMOUSE_DOWN {$$=Window::MIDDLEMOUSE_DOWN;
}
    | T_RIGHTMOUSE_DOWN {$$=Window::RIGHTMOUSE_DOWN;
}
    | T_LEFTMOUSE_UP  {$$=Window::LEFTMOUSE_UP;
}
    | T_MIDDLEMOUSE_UP {$$=Window::MIDDLEMOUSE_UP;
}
    | T_RIGHTMOUSE_UP {$$=Window::RIGHTMOUSE_UP;
}
    | T_MOUSE_MOVE {$$=Window::MOUSE_MOVE;
}
    | T_MOUSE_DRAG {$$=Window::MOUSE_DRAG;
}
    | T_AKEY {$$=Window::AKEY;
}
    | T_SKEY {$$=Window::SKEY;
}
    | T_DKEY {$$=Window::DKEY;
}
    | T_FKEY {$$=Window::FKEY;
}
    | T_HKEY {$$=Window::HKEY;
}
    | T_JKEY {$$=Window::JKEY;
}
    | T_KKEY {$$=Window::KKEY;
}
    | T_LKEY {$$=Window::LKEY;
}
    | T_WKEY {$$=Window::WKEY;
}
    | T_ZKEY {$$=Window::ZKEY;
}
    | T_F1 {$$=Window::F1;
}
    ;

 /*---------------------------------------------------------------------*/
statement_or_block_of_statements:
    statement_block{$$=$1;}
    | statement{$$=$1;}
    ;

 /*---------------------------------------------------------------------*/
statement_block:
    T_LBRACE statement_list T_RBRACE{$$ = $2;}
    | T_LBRACE T_RBRACE { $$= new NullStatement; }
    ;


 /*---------------------------------------------------------------------*/
statement_list:
    statement_list statement{
      $1->append_statement($2); $$=$1;}
    | statement{$$ = $1;}
    ;

//---------------------------------------------------------------------
statement:
    if_statement{ $$=$1; /*CHANGE*/ }
    | for_statement{ $$=$1; /*CHANGE*/ }
    | assign_statement T_SEMIC{ $$=$1; }
    | print_statement T_SEMIC{ $$ =$1;}
    | exit_statement T_SEMIC{ $$=$1; }
    ;

 /*---------------------------------------------------------------------*/
if_statement:
    T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements %prec IF_NO_ELSE{
      Gpl_type t = $3->type();
      if(t != INT){Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);}
      $$ = new If($3, $5);
    }
    | T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements T_ELSE statement_or_block_of_statements{
      Gpl_type t = $3->type();
      if(t != INT){Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);}

      $$ = new If($3, $5, $7);
    }
    ;

 /*---------------------------------------------------------------------*/
for_statement:
    T_FOR T_LPAREN assign_statement_or_empty T_SEMIC expression T_SEMIC assign_statement_or_empty T_RPAREN statement_or_block_of_statements{
      Gpl_type t = $5->type();
      
      if(t != INT){
        Error::error(Error::INVALID_TYPE_FOR_FOR_STMT_EXPRESSION);
      }
      $$ = new For($3, $5, $7, $9);
    }
    ;

 /*---------------------------------------------------------------------*/
print_statement:
    T_PRINT T_LPAREN expression T_RPAREN{
       Gpl_type t = $3->type();
       if(t != INT && t != DOUBLE && t != STRING){
         Error::error(Error::INVALID_TYPE_FOR_PRINT_STMT_EXPRESSION);
       }

       $$ = new Print($1, $3);
    }
    ;

 /*---------------------------------------------------------------------*/
exit_statement:
    T_EXIT T_LPAREN expression T_RPAREN
    {
      Gpl_type t = $3->type();
      if(t != INT){
        Error::error(Error::EXIT_STATUS_MUST_BE_AN_INTEGER, gpl_type_to_string(t));
      }
      
      $$ = new Exit($1, $3);
    }
    ;

 /*---------------------------------------------------------------------*/
assign_statement_or_empty:
    assign_statement {$$ = $1;}
    | empty{$$ = new NullStatement();}
    ;

 /*---------------------------------------------------------------------*/
assign_statement:
    variable T_ASSIGN expression{
      
      std::string name = $1->get_name() + $1->get_data_name();

      Gpl_type v = $1->type();
      Gpl_type e = $3->type();

      if(v != INT && v != DOUBLE && v != STRING && v != ANIMATION_BLOCK){
        Error::error(Error::INVALID_LHS_OF_ASSIGNMENT, name, gpl_type_to_string(v));
      }




      if(v == INT){
        if(e != INT){
          Error::error(Error::ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(v), gpl_type_to_string(e));
        }
        else{
          $$= new Assign($1, $3);
        }
      }

      else if(v == DOUBLE){
        if(e != DOUBLE && e!= INT){
          Error::error(Error::ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(v), gpl_type_to_string(e));
        }
        else{
          $$= new Assign($1, $3);
        }
      }

      else if(v == STRING){
       
        if (e != DOUBLE && e != INT && e != STRING){
          Error::error(Error::ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(v), gpl_type_to_string(e)); 
        }
        else{
          $$ = new Assign($1, $3);
        }
     }

      else if( v == ANIMATION_BLOCK){

        if(e != ANIMATION_BLOCK && e != ANIMATION_CODE){
          Error::error(Error::ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(v), gpl_type_to_string(e));
        }
        else{
          Gpl_type lhs_para_type = $1->evaluate()->as_animation_block()->get_parameter_type();
          Gpl_type rhs_para_type =  $3->evaluate()->as_animation_block()->get_parameter_type();

          if(lhs_para_type != rhs_para_type){
            Error::error(Error::ANIMATION_BLOCK_ASSIGNMENT_PARAMETER_TYPE_ERROR, gpl_type_to_string(lhs_para_type), gpl_type_to_string(rhs_para_type)); 
          }
          else{
            if(e == ANIMATION_CODE){
              Animation_code::used_blocklist.insert(dynamic_cast<Variable*>($3)->get_name());
            }
            $$ = new Assign($1, $3);
          }
         
       }
     }

      else if(v == ANIMATION_CODE){
        Error::error(Error::CANNOT_ASSIGN_TO_ANIMATION_CODE, name);
      }
    }
    | variable T_PLUS_ASSIGN expression{
      Gpl_type v = $1->type();
      Gpl_type e = $3->type();

      std::string name = $1->get_name() + $1->get_data_name();
      if(v != INT && v != DOUBLE && v != STRING ){
        Error::error(Error::INVALID_LHS_OF_PLUS_ASSIGNMENT, name, gpl_type_to_string(v));
      }
      if(v == INT){
        if(e != INT){
          Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(v), gpl_type_to_string(e));
        }
        else{
          $$= new Assign($1, new Plus($1,$3));
        }
      }

      else if(v == DOUBLE){
        if(e != DOUBLE && e!= INT){
          Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(v), gpl_type_to_string(e));
        }
        else{
          $$= new Assign($1, new Plus($1, $3));
        }
      }

      else if(v == STRING){
       
        if (e != DOUBLE && e != INT && e != STRING){
          Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(v), gpl_type_to_string(e)); 
        }
        else{
          $$ = new Assign($1, new Plus($1, $3));
        }
     }

      else if( v == ANIMATION_BLOCK){
      std::cerr << "animation block, should not be here yet\n\n";
      }
          $$ = new Assign($1, new Plus($1, $3));


    } 
    | variable T_MINUS_ASSIGN expression{
      Gpl_type v = $1->type();
      Gpl_type e = $3->type();
      std::string name = $1->get_name() + $1->get_data_name();
      if(v != INT && v != DOUBLE && v ){
        Error::error(Error::INVALID_LHS_OF_MINUS_ASSIGNMENT, name, gpl_type_to_string(v));
      
    }
      if(v == INT){
        if(e != INT){
          Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(v), gpl_type_to_string(e));
        }
        else{
          $$= new Assign($1, new Minus($1,$3));
        }
      }

      else if(v == DOUBLE){
        if(e != DOUBLE && e!= INT){
          Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR, gpl_type_to_string(v), gpl_type_to_string(e));
        }
        else{
          $$= new Assign($1, new Minus($1, $3));
        }
      }

          $$= new Assign($1, new Minus($1, $3));

    }
    | variable T_PLUS_PLUS{

      std::string name = $1->get_name() + $1->get_data_name();
      Gpl_type v = $1->type();
      if(v != INT){
        Error::error(Error::INVALID_LHS_OF_PLUS_PLUS, name, gpl_type_to_string(v));
      }
      $$=new Assign($1, new Plus($1, new Integer_constant(1))); 

    }
    | variable T_MINUS_MINUS{

      std::string name = $1->get_name() + $1->get_data_name();
      Gpl_type v = $1->type();
      if(v != INT){
        Error::error(Error::INVALID_LHS_OF_MINUS_MINUS, name, gpl_type_to_string(v));
      }
      $$=new Assign($1, new Minus($1, new Integer_constant(1)));

    }

    ;

 /*---------------------------------------------------------------------*/
variable:
    T_ID{
      Table_handler& th = Table_handler::instance();
      std::shared_ptr<Symbol> x = th.lookup(*$1);
      if(x->get_count() > 0){ //index is an array
        Error::error(Error::VARIABLE_IS_AN_ARRAY, x->get_name());
        $$ = new Variable("");
        break;
      }
      if(x != nullptr){ $$ = new Variable(x->get_name());}
      else{ $$ = new Variable("");}
    }
    | T_ID T_LBRACKET expression T_RBRACKET{
         Table_handler& th = Table_handler::instance();
        std::shared_ptr<Symbol> x = th.lookup(*$1);
        if($3->type() != INT){
          Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, gpl_type_to_string($3->type()));
        }
        if( x->get_count() == -1){
          Error::error(Error::VARIABLE_NOT_AN_ARRAY, *$1);
        }
      /* if( $3->evaluate()->as_int() < 0){
         Error::error(Error::ARRAY_INDEX_OUT_OF_BOUNDS, *$1, std::to_string($3->evaluate()->as_int()));
       }*/ 

 
        if(x != nullptr){ 
          $$ = new Variable(x->get_name(), $3);
        }
        else{ $$ = new Variable("");}
      }


    | T_ID T_PERIOD T_ID{
     
      Table_handler& th = Table_handler::instance();
      std::shared_ptr<Symbol> x = th.lookup(*$1);
      if(x == nullptr){
        Error::error(Error::UNDECLARED_VARIABLE, *$1);
        delete $1; delete $3;
        $$=new Variable("");
        break;
      }

      if (x->get_count() > -1){
          Error::error(Error::VARIABLE_IS_AN_ARRAY, *$1);
        delete $1;
        $$=new Variable("");
        break;
      }

      try { std::shared_ptr<const Constant>(x->as_constant(*$3)); }
      catch(Gpl_type bad_type) {
        Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT, *$1);
        $$=new Variable("");
        break;
      }
      catch(const out_of_range& oor) {
        Error::error(Error::UNDECLARED_MEMBER,*$1,*$3);
        $$=new Variable("");
        break;
      }
      $$ = new Member_variable(*$1, *$3);
      delete $1;   
      
    }
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID { 
      Table_handler& th = Table_handler::instance();
      std::shared_ptr<Symbol> x = th.lookup(*$1);
      if(x == nullptr){
       Error::error(Error::UNDECLARED_VARIABLE, *$1 + "[]");
       $$ = new Variable("");
       break;
      }
      if( $3->type() != INT)
      {
        Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, gpl_type_to_string($3->type()));
        $$ = new Variable("");
        break;
      }
      if(x->get_count() < 1){// ID not an array
         Error::error(Error::VARIABLE_NOT_AN_ARRAY, x->get_name());
         $$ = new Variable("");
         break;

      }
      
      try { std::shared_ptr<const Constant>(x->as_constant(0, *$6)); }
      catch(const out_of_range& oor)
      {
      
        Error::error(Error::UNDECLARED_MEMBER, *$1, *$6);
        $$ = new Variable("");
        break;
      }
      catch(Gpl_type badtype)
      {
        Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT, *$1);
        $$ = new Variable("");
        break;
      }
      $$ = new Member_variable(*$1, $3, *$6);
         

    }
    ;

 /*---------------------------------------------------------------------*/
expression:
    primary_expression {$$=$1;}
    | expression T_OR expression 
      {
        $$=Bin_op_check<Or, OR>($1,$3,INT|DOUBLE);
      }
    | expression T_AND expression 
      {
        $$=Bin_op_check<And, AND>($1,$3,INT|DOUBLE);
      }
    | expression T_LESS_EQUAL expression 
      {
        $$=Bin_op_check<Less_equal, LESS_EQUAL>($1, $3, INT|DOUBLE|STRING);
      }
        
    | expression T_GREATER_EQUAL  expression {$$=Bin_op_check<Greater_equal, GREATER_EQUAL>($1, $3, INT|DOUBLE|STRING);}
    | expression T_LESS expression {$$=Bin_op_check<Less_than, LESS_THAN>($1, $3, INT|DOUBLE|STRING);}
    | expression T_GREATER  expression {$$=Bin_op_check<Greater_than, GREATER_THAN>($1, $3, INT|DOUBLE|STRING); }
    | expression T_EQUAL expression {$$=Bin_op_check<Equal, EQUAL>($1, $3, INT|DOUBLE|STRING); }
    | expression T_NOT_EQUAL expression {$$=Bin_op_check<Not_equal, NOT_EQUAL>($1, $3, INT|DOUBLE|STRING);}
    | expression T_PLUS expression 
      {
        unsigned int lh_valid=$1->type() & (INT|DOUBLE|STRING);
        unsigned int rh_valid=$1->type() & (INT|DOUBLE|STRING);
        if(!lh_valid){ Error::error(Error::INVALID_LEFT_OPERAND_TYPE,operator_to_string(PLUS)); }
        if(!rh_valid){ Error::error(Error::INVALID_RIGHT_OPERAND_TYPE,operator_to_string(PLUS)); }
        
        if(lh_valid && rh_valid){ $$ = new Plus($1,$3); }
        else { $$ = new Integer_constant(0); } 
      }
    | expression T_MINUS expression 
      {
        $$=Bin_op_check<Minus, MINUS>($1,$3,INT|DOUBLE);
      }
    | expression T_MULTIPLY expression 
      {
        $$=Bin_op_check<Multiply, MULTIPLY>($1,$3,INT|DOUBLE);
      }
    | expression T_NEAR expression {$$=Bin_op_check<Near,NEAR>($1,$3, GAME_OBJECT);}
    | expression T_TOUCHES expression { $$=Bin_op_check<Touches,TOUCHES>($1,$3, GAME_OBJECT);}
    | expression T_DIVIDE expression 
      {
        $$=Bin_op_check<Divide, DIVIDE>($1,$3,INT|DOUBLE);
      }
    | expression T_MOD expression 
      {
        $$=Bin_op_check<Modulus, MOD>($1,$3,INT);
      }
    | T_MINUS  expression %prec UNARY_OPS 
      {
        unsigned int value_valid = $2->type() & (INT|DOUBLE);
        if(!value_valid) {Error::error(Error::INVALID_RIGHT_OPERAND_TYPE,operator_to_string(UNARY_MINUS));}
        if(value_valid){ $$ = new Negate($2);}
        else {$$ = new Integer_constant(0); }
      }
    | T_NOT  expression 
      {
        unsigned int value_valid = $2->type() & (INT|DOUBLE);
        if(!value_valid) {Error::error(Error::INVALID_RIGHT_OPERAND_TYPE,operator_to_string(NOT));}
        if(value_valid){ $$ = new Not($2);}
        else {$$ = new Integer_constant(0); }

      }
    | T_SIN T_LPAREN expression T_RPAREN 
      {
        unsigned int value_valid = $3->type() & (INT|DOUBLE);
        if(!value_valid) {Error::error(Error::INVALID_RIGHT_OPERAND_TYPE,operator_to_string(SIN));}
        if(value_valid){ $$ = new Sine($3);}
        else {$$ = new Integer_constant(0); }
      }
    | T_COS T_LPAREN expression T_RPAREN 
      {
        unsigned int value_valid = $3->type() & (INT|DOUBLE);
        if(!value_valid) {Error::error(Error::INVALID_RIGHT_OPERAND_TYPE,operator_to_string(COS));}
        if(value_valid){ $$ = new Cosine($3);}
        else {$$ = new Integer_constant(0); }
      }
    | T_TAN T_LPAREN expression T_RPAREN 
      {
        $$=Un_op_chack<Tangent, TAN>($3,INT|DOUBLE); 
      }
    | T_ASIN T_LPAREN expression T_RPAREN 
      {
        $$=Un_op_chack<Arc_sine, ASIN>($3,INT|DOUBLE); 
      }
    | T_ACOS T_LPAREN expression T_RPAREN 
      {
        $$=Un_op_chack<Arc_cosine, ACOS>($3,INT|DOUBLE); 
      }
    | T_ATAN T_LPAREN expression T_RPAREN 
      {
        $$=Un_op_chack<Arc_tangent, ATAN>($3,INT|DOUBLE); 
      }
    | T_SQRT T_LPAREN expression T_RPAREN 
      {
        $$=Un_op_chack<Square_root, SQRT>($3,INT|DOUBLE); 
      }
    | T_ABS T_LPAREN expression T_RPAREN 
      {
        $$=Un_op_chack<Absolute_value, ABS>($3,INT|DOUBLE); 
      }
    | T_FLOOR T_LPAREN expression T_RPAREN 
      {
        $$=Un_op_chack<Floor, FLOOR>($3,INT|DOUBLE); 
      }
    | T_RANDOM T_LPAREN expression T_RPAREN 
      {
        unsigned int value_valid = $3->type() & (INT|DOUBLE);
        if(!value_valid) {Error::error(Error::INVALID_RIGHT_OPERAND_TYPE,operator_to_string(RANDOM));}
        if(value_valid){ 
          int check = $3->evaluate()->as_double();
          
          if(check < 1){
            Error::error(Error::INVALID_ARGUMENT_FOR_RANDOM, $3->evaluate()->as_string());
            $$ = new Integer_constant(0);
          }
          else{ $$ = new Random($3);}
        }
        else{$$ = new Integer_constant(0);} 
       /* int check = $3->evaluate()->as_double();
        if(check < 1) {Error::error(Error::INVALID_ARGUMENT_FOR_RANDOM, $3->evaluate()->as_string());}
        $$=Un_op_chack<Random, RANDOM>($3,INT|DOUBLE);*/
        
      }
    ;

 /*---------------------------------------------------------------------*/
primary_expression:
    T_LPAREN  expression T_RPAREN {$$=$2;}
    | variable {$$=$1;}
    | T_INT_CONSTANT {$$= new Integer_constant($1);}
    | T_TRUE {$$=new Integer_constant(1);}
    | T_FALSE {$$=new Integer_constant(0);}
    | T_DOUBLE_CONSTANT {$$=new Double_constant($1);}
    | T_STRING_CONSTANT {$$=new String_constant(*$1); delete $1;}
    ;

 /*---------------------------------------------------------------------*/
empty:
    // empty goes to nothing so that you can use empty in productions
    // when you want a production to go to nothing
    ;

%%
